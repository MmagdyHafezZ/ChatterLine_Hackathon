import { useCallback, useEffect, useState } from "react";
import * as Calendar from "expo-calendar";
import * as Notifications from "expo-notifications";
import { Alert, Platform } from "react-native";
import dayjs from "dayjs";
import { CallEvent } from "../types";

interface CalendarEvent {
  id: string;
  title: string;
  startDate: Date;
  endDate: Date;
  location?: string;
  notes?: string;
  attendees?: string[];
}

export const useCalendarIntegration = () => {
  const [calendars, setCalendars] = useState<Calendar.Calendar[]>([]);
  const [hasPermission, setHasPermission] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const requestPermissions = useCallback(async () => {
    try {
      const { status } = await Calendar.requestCalendarPermissionsAsync();
      const hasAccess = status === "granted";
      setHasPermission(hasAccess);

      if (hasAccess) {
        const deviceCalendars = await Calendar.getCalendarsAsync(
          Calendar.EntityTypes.EVENT
        );
        setCalendars(deviceCalendars);
      }

      return hasAccess;
    } catch (error) {
      console.error("Calendar permission error:", error);
      return false;
    }
  }, []);

  const getCalendarEvents = useCallback(
    async (startDate: Date, endDate: Date): Promise<CalendarEvent[]> => {
      if (!hasPermission) return [];

      try {
        setIsLoading(true);
        const events = await Calendar.getEventsAsync(
          calendars.map((cal) => cal.id),
          startDate,
          endDate
        );

        return events.map((event) => ({
          id: event.id,
          title: event.title,
          startDate: new Date(event.startDate),
          endDate: new Date(event.endDate),
          location: event.location,
          notes: event.notes,
          attendees: event.attendees?.map((a) => a.email).filter(Boolean),
        }));
      } catch (error) {
        console.error("Error fetching calendar events:", error);
        return [];
      } finally {
        setIsLoading(false);
      }
    },
    [hasPermission, calendars]
  );

  const createCalendarEvent = useCallback(
    async (callEvent: CallEvent): Promise<string | null> => {
      if (!hasPermission || calendars.length === 0) return null;

      try {
        const defaultCalendar =
          calendars.find((cal) => cal.isPrimary) || calendars[0];

        const eventDetails = {
          title: `AI Call: ${callEvent.title}`,
          startDate: callEvent.scheduledTime,
          endDate: dayjs(callEvent.scheduledTime)
            .add(callEvent.duration, "minute")
            .toDate(),
          notes: `${callEvent.description || ""}\n\nGenerated by AI Call Assistant`,
          location: "AI Call Assistant",
          timeZone: "GMT",
          alarms: [
            { relativeOffset: -15 * 60 }, // 15 minutes before
            { relativeOffset: -5 * 60 }, // 5 minutes before
          ],
        };

        const eventId = await Calendar.createEventAsync(
          defaultCalendar.id,
          eventDetails
        );
        return eventId;
      } catch (error) {
        console.error("Error creating calendar event:", error);
        return null;
      }
    },
    [hasPermission, calendars]
  );

  const checkTimeSlotAvailability = useCallback(
    async (
      startTime: Date,
      duration: number
    ): Promise<{ available: boolean; conflicts: CalendarEvent[] }> => {
      const endTime = dayjs(startTime).add(duration, "minute").toDate();
      const events = await getCalendarEvents(startTime, endTime);

      const conflicts = events.filter((event) => {
        const eventStart = dayjs(event.startDate);
        const eventEnd = dayjs(event.endDate);
        const slotStart = dayjs(startTime);
        const slotEnd = dayjs(endTime);

        return slotStart.isBefore(eventEnd) && slotEnd.isAfter(eventStart);
      });

      return {
        available: conflicts.length === 0,
        conflicts,
      };
    },
    [getCalendarEvents]
  );

  const suggestOptimalTimes = useCallback(
    async (
      preferredDate: Date,
      duration: number,
      workingHours: { start: number; end: number } = { start: 9, end: 17 }
    ): Promise<Date[]> => {
      const suggestions: Date[] = [];
      const date = dayjs(preferredDate).startOf("day");

      // Check every 30-minute slot during working hours
      for (let hour = workingHours.start; hour < workingHours.end; hour++) {
        for (let minute = 0; minute < 60; minute += 30) {
          const timeSlot = date.hour(hour).minute(minute).toDate();
          const { available } = await checkTimeSlotAvailability(
            timeSlot,
            duration
          );

          if (available) {
            suggestions.push(timeSlot);
          }

          if (suggestions.length >= 6) break;
        }
        if (suggestions.length >= 6) break;
      }

      return suggestions;
    },
    [checkTimeSlotAvailability]
  );

  useEffect(() => {
    requestPermissions();
  }, [requestPermissions]);

  return {
    hasPermission,
    calendars,
    isLoading,
    requestPermissions,
    getCalendarEvents,
    createCalendarEvent,
    checkTimeSlotAvailability,
    suggestOptimalTimes,
  };
};
